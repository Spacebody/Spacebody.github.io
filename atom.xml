<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风居住的街道</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yilin.dev/"/>
  <updated>2019-09-13T12:18:12.018Z</updated>
  <id>https://blog.yilin.dev/</id>
  
  <author>
    <name>Yilin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Learning Compiler 5</title>
    <link href="https://blog.yilin.dev/2019/08/24/Learn-compiler-5/"/>
    <id>https://blog.yilin.dev/2019/08/24/Learn-compiler-5/</id>
    <published>2019-08-24T03:36:14.550Z</published>
    <updated>2019-09-13T12:18:12.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="The-Functionality-of-the-Parser"><a href="#The-Functionality-of-the-Parser" class="headerlink" title="The Functionality of the Parser"></a>The Functionality of the Parser</h3><ul><li><strong>Input</strong>: sequence of tokens from lexer</li><li><strong>Output</strong>: parse tree of the program</li></ul><h3 id="Comparison-with-Lexical-Analysis"><a href="#Comparison-with-Lexical-Analysis" class="headerlink" title="Comparison with Lexical Analysis"></a>Comparison with Lexical Analysis</h3><table><thead><tr><th align="center">Phase</th><th align="center">Input</th><th align="center">Output</th></tr></thead><tbody><tr><td align="center">Lexer</td><td align="center">String of characters</td><td align="center">String of tokens</td></tr><tr><td align="center">Parser</td><td align="center">String of token</td><td align="center">Parse tree</td></tr></tbody></table><h3 id="The-Role-of-the-Parser"><a href="#The-Role-of-the-Parser" class="headerlink" title="The Role of the Parser"></a>The Role of the Parser</h3><ol><li>Not all strings of tokens are programs</li><li>Parser must distinguish between valid and invalid strings of tokens</li></ol><p>So we need:</p><ul><li>A language for describing valid strings of tokens</li><li>A method for distinguishing valid from invalid strings of tokens</li></ul><h3 id="Context-Free-Grammars-CFG"><a href="#Context-Free-Grammars-CFG" class="headerlink" title="Context-Free Grammars(CFG)"></a>Context-Free Grammars(CFG)</h3><ul><li>Programming language constructs have recursive structure</li><li>Context-free grammars are a natural notation for the recursive structure</li></ul><p>A CFG consists of:</p><ul><li>A set of terminals <span>$T$</span><!-- Has MathJax --></li><li>A set of non-terminals <span>$N$</span><!-- Has MathJax --></li><li>A start symbol <span>$S$</span><!-- Has MathJax --> (a non-terminal)</li><li>A set of productions <span>$X \rightarrow Y_1Y_2\dots Y_n$</span><!-- Has MathJax -->, where <span>$X \in N$</span><!-- Has MathJax --> and <span>$Y_i \in T \cup N \cup \{\epsilon\}$</span><!-- Has MathJax -->.</li></ul><h3 id="Examples-of-CFGs"><a href="#Examples-of-CFGs" class="headerlink" title="Examples of CFGs"></a>Examples of CFGs</h3><p>E \rightarrow E * E<br>   | E + E<br>   | (E)<br>   | id</p><h3 id="Key-Idea"><a href="#Key-Idea" class="headerlink" title="Key Idea"></a>Key Idea</h3><ol><li>Begin with a string consisting of the start symbol “S”</li><li>Replace any non-terminal <span>$X$</span><!-- Has MathJax --> in the string by a the right-hand side of some production <span>$X \rightarrow Y_1Y_2\dots Y_n$</span><!-- Has MathJax --></li><li>Repeat (2) until there are no non-terminals in the string</li></ol><h3 id="The-Language-of-a-CFG"><a href="#The-Language-of-a-CFG" class="headerlink" title="The Language of a CFG"></a>The Language of a CFG</h3><p>Read productions as rules:</p><span>$X \rightarrow Y_1Y_2\dots Y_n$</span><!-- Has MathJax --><p>means <span>$X$</span><!-- Has MathJax --> can be replaced by <span>$Y_1Y_2\dots Y_n$</span><!-- Has MathJax --></p><p>More formally, write</p><span>$X_1\dots X_{i-1}X_i X_{i+1}\dots X_n \rightarrow X_1\dots X_{i-1} Y_1\dots Y_m X_{i+1}\dots X_n$</span><!-- Has MathJax --><p>if there is a production</p><span>$X_i \rightarrow Y_1Y_2\dots Y_m$</span><!-- Has MathJax --><p>Write</p><span>$X_1\dots X_n \rightarrow *Y_1\dots Y_m$</span><!-- Has MathJax --><p>if</p><span>$X_1\dots X_n \rightarrow \dots \rightarrow \dots \rightarrow Y_1\dots Y_m$</span><!-- Has MathJax --><p>in 0 or more steps</p><p>Let <span>$G$</span><!-- Has MathJax --> be a context-free grammer with start symbol <span>$S$</span><!-- Has MathJax -->. Then the language of <span>$G$</span><!-- Has MathJax --> is</p><span>$\{a_1\dots a_n | S \rightarrow *a_1\dots a_n \text{and every} a_i \text{is a terminal}\}$</span><!-- Has MathJax --><h3 id="Terminals"><a href="#Terminals" class="headerlink" title="Terminals"></a>Terminals</h3><ul><li>Terminals are so-called because there are no rules for replacing them</li><li>Once generated, terminals are permanent</li><li>Terminals ought to be tokens of the language</li></ul><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><p>The idea of a CFG is a big step. But:</p><ul><li>Membership in a language is “yes” or “no”<ul><li>We also need a parse tree of the input</li></ul></li><li>Must handle errors gracefully</li><li>Need an implementation of CFG’s (e.g. bison)</li><li>Form of the grammar is important<ul><li>Many grammars generate the same language</li><li>Tools are sensitive to the grammar<br>(Tools for regular languages (e.g., flex) are sensitive to the form of the regular expression, but this is rarely a problem in practice)</li></ul></li></ul><h3 id="Derivations-and-Parse-Trees"><a href="#Derivations-and-Parse-Trees" class="headerlink" title="Derivations and Parse Trees"></a>Derivations and Parse Trees</h3><p>A derivation is a sequence of productions</p><span>$S \rightarrow \dots \rightarrow \dots \dots$</span><!-- Has MathJax --><p>A derivation can be drawn as a tree</p><ul><li>Start symbol is the tree’s root</li><li>For a production <span>$X \rightarrow Y_1 \dots Y_n$</span><!-- Has MathJax --> add children <span>$Y_1 \dots Y_n$</span><!-- Has MathJax --> to node <span>$X$</span><!-- Has MathJax --></li></ul><p>Letf-most and right-most derivations have the same parse tree, the difference is the order in which branches are added.</p><h3 id="Summary-of-Derivations"><a href="#Summary-of-Derivations" class="headerlink" title="Summary of Derivations"></a>Summary of Derivations</h3><p>We are not just interested in whether s c L(G)</p><ul><li>We need a parse tree for <span>$s \in L(G)$</span><!-- Has MathJax --><ul><li>A derivation defines a parse tree</li></ul></li><li>But one parse tree may have many derivations<ul><li>Left-most and right-most derivations are important in parser implementation</li></ul></li></ul><h3 id="Ambiguity"><a href="#Ambiguity" class="headerlink" title="Ambiguity"></a>Ambiguity</h3><ul><li>A grammar is ambiguous if it has more than one parse tree for some string<ul><li>Equivalently, there is more than one right-most or left-most derivation for some string</li></ul></li><li>Ambiguity is BAD<ul><li>Leaves meaning of some programs ill-defined</li></ul></li></ul><h3 id="Dealing-with-Ambiguity"><a href="#Dealing-with-Ambiguity" class="headerlink" title="Dealing with Ambiguity"></a>Dealing with Ambiguity</h3><ul><li>There are several ways to handle ambiguity</li><li>Most direct method is to rewrite grammar unambiguously</li><li>Enforces precedence of * over +</li></ul><p>cases:</p><ul><li><p>Ambiguity in Arithmetic Expressions: E -&gt; E + E | E * E | ( E ) | int</p></li><li><p>The Dangling Else: E -&gt; if E then E | if E then E else E | OTHER</p><ul><li>Fix: else matches the closest unmatched then</li></ul></li><li><p>No general techniques for handling ambiguity</p></li><li><p>Impossible to convert automatically an ambiguous grammar to an unambiguous one</p><ul><li>Used with care, ambiguity can simplify the grammar</li><li>Sometimes allows more natural definitions –  We need disambiguation mechanisms</li></ul></li></ul><h3 id="Precedence-and-Associativity-Declarations"><a href="#Precedence-and-Associativity-Declarations" class="headerlink" title="Precedence and Associativity Declarations"></a>Precedence and Associativity Declarations</h3><ul><li>Instead of rewriting the grammar<ul><li>Use the more natural (ambiguous) grammar</li><li>Along with disambiguating declarations</li></ul></li><li>Most tools allow precedence and associativity declarations to disambiguate grammars<ul><li>Examples:<ul><li>Left associativity declaration: %left +</li><li>Precedence declarations: %left +, %left *</li></ul></li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture05.pdf" target="_blank" rel="noopener">Introduction to Parsing</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;The-Functionality-of-the-Parser&quot;&gt;&lt;a href=&quot;#The-Functional
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="Compiler" scheme="https://blog.yilin.dev/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Learning Bitcoin and Cryptocurrencies 1 Basic Concepts</title>
    <link href="https://blog.yilin.dev/2019/05/28/Learn-Bitcoin-and-Cryptocurrencies-1/"/>
    <id>https://blog.yilin.dev/2019/05/28/Learn-Bitcoin-and-Cryptocurrencies-1/</id>
    <published>2019-05-28T07:48:23.924Z</published>
    <updated>2019-05-28T08:58:05.011Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="What-is-Bitcoin"><a href="#What-is-Bitcoin" class="headerlink" title="What is Bitcoin?"></a>What is Bitcoin?</h3><h4 id="Basic-Concept"><a href="#Basic-Concept" class="headerlink" title="Basic Concept"></a>Basic Concept</h4><p>The first and most widely used cryptocurrency: completely digital, decentralized, currency built on principles of computer science, cryptography, and economics</p><p>Bitcoin: refers to the community, the network, and the software</p><p>bitcoins: the currency itself, a unit</p><p>Inspiration for the blockchain: the underlying data structure that stores a permanent history of all transactions to ever occur the history of bitcoin</p><h4 id="The-Cypherpunks-Movement"><a href="#The-Cypherpunks-Movement" class="headerlink" title="The Cypherpunks Movement"></a>The Cypherpunks Movement</h4><p>Cypherpunks = a group of people who advocate for the protection of privacy using cyptography</p><p>Bitcoin was created by Satoshi Nakamoto in 2009. He created the first ever decentralized, pseudonymous, and trustless system for transactions</p><h4 id="Satoshi-Nakamoto’s-Innovation"><a href="#Satoshi-Nakamoto’s-Innovation" class="headerlink" title="Satoshi Nakamoto’s Innovation"></a>Satoshi Nakamoto’s Innovation</h4><p>Bitcoin attempts to solve two problems that decentralized networks typically face:</p><ul><li>Inconsistent transactions records held by different nodes</li><li>Malicious pseudonymous actors might broadcast false messages and divide the network</li></ul><p>Double spending attack: asynchronous records held by different nodes</p><p>The blockchain and consensus protocol are the solution</p><h3 id="Bitcoin-vs-Banks"><a href="#Bitcoin-vs-Banks" class="headerlink" title="Bitcoin vs. Banks"></a>Bitcoin vs. Banks</h3><h4 id="Banks-Services"><a href="#Banks-Services" class="headerlink" title="Banks Services"></a>Banks Services</h4><p>Account and identity management</p><p>Service</p><p>Record management</p><p>Trust</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://courses.edx.org/courses/course-v1:BerkeleyX+CS198.1x+3T2018" target="_blank" rel="noopener">BerkeleyX: CS198.1x Bitcoin and Cryptocurrencie</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;What-is-Bitcoin&quot;&gt;&lt;a href=&quot;#What-is-Bitcoin&quot; class=&quot;header
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="Bitcoin" scheme="https://blog.yilin.dev/tags/Bitcoin/"/>
    
      <category term="Cryptocurrencies" scheme="https://blog.yilin.dev/tags/Cryptocurrencies/"/>
    
  </entry>
  
  <entry>
    <title>Learning Compiler 4 Finite Automata</title>
    <link href="https://blog.yilin.dev/2019/05/21/Learn-compiler-4/"/>
    <id>https://blog.yilin.dev/2019/05/21/Learn-compiler-4/</id>
    <published>2019-05-21T05:26:17.236Z</published>
    <updated>2019-05-22T12:15:35.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Specifying-Lexical-Structure-Using-Regular-Expressions"><a href="#Specifying-Lexical-Structure-Using-Regular-Expressions" class="headerlink" title="Specifying Lexical Structure Using Regular Expressions"></a>Specifying Lexical Structure Using Regular Expressions</h3><p>Union: <span>$A|B\equiv A + B$</span><!-- Has MathJax --><br>Option: <span>$A + \epsilon \equiv A?$</span><!-- Has MathJax --><br>Range: <span>$&apos;a&apos;+&apos;b&apos;+\dots+&apos;z&apos;\equiv [a-z]$</span><!-- Has MathJax --><br>Excluded range: complement of <span>$[a-z] \equiv [\hat{}a-z]$</span><!-- Has MathJax --></p><h3 id="Regular-Expressions-gt-Lexical-Spec"><a href="#Regular-Expressions-gt-Lexical-Spec" class="headerlink" title="Regular Expressions =&gt; Lexical Spec."></a>Regular Expressions =&gt; Lexical Spec.</h3><ol><li>Write a rexp for the lexemes of each token</li><li>Construct <span>$R$</span><!-- Has MathJax -->, matching all lexemes for all tokens<ul><li><span>$R = \text{Keyword} + \text{Identifier} + \text{Number} + \dots \\ = R_1 + R_2 + \dots$</span><!-- Has MathJax --></li></ul></li><li>Let input be <span>$x_1\dots x_n$</span><!-- Has MathJax --><ul><li>For <span>$1 \leq i \leq n$</span><!-- Has MathJax --> check <span>$x_1\dots x_i\in L(R)$</span><!-- Has MathJax --></li></ul></li><li>If success, then we know that <span>$x_1\dots x_i\in L(R_j)$</span><!-- Has MathJax --> for some <span>$j$</span><!-- Has MathJax --></li><li>Remove <span>$x_1\dots x_i$</span><!-- Has MathJax --> from input and go to (3)</li></ol><h3 id="Ambiguities"><a href="#Ambiguities" class="headerlink" title="Ambiguities"></a>Ambiguities</h3><p>Rule: Pick longest possible string in <span>$L(R)$</span><!-- Has MathJax --></p><p>Rule: Use rule listed first</p><h3 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h3><p>No rule matches a prefix of input</p><p>Solution:</p><ul><li>Write a rule matching all “bad” strings</li><li>Put it last (lowest priority)</li></ul><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>Regular expressions provide a concise notation for string patterns</p><p>Use in lexical analysis requires small extensions</p><ul><li>To resolve ambiguities</li><li>To handle errors</li></ul><p>Good algorithms known</p><ul><li>Require only single pass over the input</li><li>Few operations per character (table lookup)</li></ul><h3 id="Finite-Automata"><a href="#Finite-Automata" class="headerlink" title="Finite Automata"></a>Finite Automata</h3><p>Regular expressions = specification</p><p>Finite automata = implementation</p><p>A finite automaton consists of –  An input alphabet <span>$\Sigma$</span><!-- Has MathJax --></p><ul><li>A set of states <span>$S$</span><!-- Has MathJax --></li><li>A start state <span>$n$</span><!-- Has MathJax --></li><li>A set of accepting states <span>$F\subseteq S$</span><!-- Has MathJax --></li><li>A set of transitions state <span>$\rightarrow^{\text{input}}$</span><!-- Has MathJax --> state</li></ul><p>Transition: <span>$s_1 \rightarrow^{a} s_2$</span><!-- Has MathJax --></p><p>Is read: In state <span>$s_1$</span><!-- Has MathJax --> on input “a” go to state <span>$s_2$</span><!-- Has MathJax --></p><p>If end of input and in accepting state =&gt; accept</p><p>Otherwise =&gt; reject</p><h3 id="Finite-Automata-State-Graphs"><a href="#Finite-Automata-State-Graphs" class="headerlink" title="Finite Automata State Graphs"></a>Finite Automata State Graphs</h3><p><img src="/figures/FASG.png" alt="Finite Automata State Graphs"></p><h3 id="Epsilon-Moves"><a href="#Epsilon-Moves" class="headerlink" title="Epsilon Moves"></a>Epsilon Moves</h3><p>$\epsilon$-moves</p><p><img src="/figures/epsilon-move.png" alt="Epsilon Moves"></p><p>Machine can move from state A to state B without reading input</p><h3 id="Deterministic-and-Nondeterministic-Automata"><a href="#Deterministic-and-Nondeterministic-Automata" class="headerlink" title="Deterministic and Nondeterministic Automata"></a>Deterministic and Nondeterministic Automata</h3><p>Deterministic Finite Automata (DFA)</p><ul><li>One transition per input per state</li><li>No <span>$\epsilon$</span><!-- Has MathJax -->-moves</li></ul><p>Nondeterministic Finite Automata (NFA)</p><ul><li>Can have multiple transitions for one input in a<br>given state</li><li>Can have <span>$\epsilon$</span><!-- Has MathJax -->-moves</li></ul><h3 id="Execution-of-Finite-Automata"><a href="#Execution-of-Finite-Automata" class="headerlink" title="Execution of Finite Automata"></a>Execution of Finite Automata</h3><p>A DFA can take only one path through the state graph</p><ul><li>Completely determined by input</li></ul><p>NFAs can choose</p><ul><li>Whether to make <span>$\epsilon$</span><!-- Has MathJax -->-moves</li><li>Which of multiple transitions for a single input to take</li></ul><h3 id="Acceptance-of-NFAs"><a href="#Acceptance-of-NFAs" class="headerlink" title="Acceptance of NFAs"></a>Acceptance of NFAs</h3><p>An NFA can get into multiple states</p><p>Rule: NFA accepts if it can get to a final state</p><h3 id="NFA-vs-DFA"><a href="#NFA-vs-DFA" class="headerlink" title="NFA vs. DFA"></a>NFA vs. DFA</h3><p>NFAs and DFAs recognize the same set of languages (regular languages)</p><p>DFAs are faster to execute</p><ul><li>No choices to consider</li></ul><p>For a given language NFA can be simpler than DFA</p><p>DFA can be exponentially larger than NFA</p><h3 id="Regular-Expressions-to-Finite-Automata"><a href="#Regular-Expressions-to-Finite-Automata" class="headerlink" title="Regular Expressions to Finite Automata"></a>Regular Expressions to Finite Automata</h3><p>High-level sketch:</p><p>Lexical Specification -&gt; Regular Expressions -&gt; NFA -&gt; DFA -&gt; Table-driven Implementation of DFA</p><h3 id="Regular-Expressions-to-NFA"><a href="#Regular-Expressions-to-NFA" class="headerlink" title="Regular Expressions to NFA"></a>Regular Expressions to NFA</h3><p><img src="/figures/rexp2nfa1.png" alt="Regular Expressions to NFA 1"></p><p><img src="/figures/rexp2nfa2.png" alt="Regular Expressions to NFA 1"></p><p><img src="/figures/rexp2nfa3.png" alt="Regular Expressions to NFA 1"></p><h3 id="NFA-to-DFA-The-Trick"><a href="#NFA-to-DFA-The-Trick" class="headerlink" title="NFA to DFA: The Trick"></a>NFA to DFA: The Trick</h3><p>Simulate the NFA</p><p>Each state of DFA = a non-empty subset of states of the NFA</p><p>Start state = the set of NFA states reachable through <span>$\epsilon$</span><!-- Has MathJax -->-moves from NFA start state</p><p>Add a transition <span>$S \rightarrow^a S&apos;$</span><!-- Has MathJax --> to DFA iff <span>$S&apos;$</span><!-- Has MathJax --> is the set of NFA states reachable from any<br>state in <span>$S$</span><!-- Has MathJax --> after seeing the input <span>$a$</span><!-- Has MathJax -->, considering <span>$\epsilon$</span><!-- Has MathJax -->-moves as well</p><h3 id="NFA-to-DFA-Remark"><a href="#NFA-to-DFA-Remark" class="headerlink" title="NFA to DFA. Remark"></a>NFA to DFA. Remark</h3><p>An NFA may be in many states at any time</p><p>If there are N states, the NFA must be in some subset of those N states</p><p>How many subsets are there?</p><ul><li><span>$2^N - 1$</span><!-- Has MathJax --> = finitely many</li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><img src="/figures/nfa2dfa_example.png" alt="NFA to DFA Example"></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>A DFA can be implemented by a 2D table T</p><ul><li>One dimension is “states”</li><li>Other dimension is “input symbol”</li><li>For every transition <span>$S_i \rightarrow^a S_k$</span><!-- Has MathJax --> define <span>$T[i, a] = k$</span><!-- Has MathJax --></li></ul><p>DFA “execution”</p><ul><li>If in state <span>$S_i$</span><!-- Has MathJax --> and input <span>$a$</span><!-- Has MathJax -->, read <span>$T[i, a] = k$</span><!-- Has MathJax --> and skip to state <span>$S_k$</span><!-- Has MathJax --></li><li>Very efficient</li></ul><p>NFA -&gt; DFA conversion is at the heart of tools such as flex</p><p>DFAs can be huge</p><p>In practice, flex-like tools trade off speed for space in the choice of NFA and DFA representations</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture04.pdf" target="_blank" rel="noopener">Finite Automata</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;Specifying-Lexical-Structure-Using-Regular-Expressions&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="Compiler" scheme="https://blog.yilin.dev/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Learning Economics 1 Introduction</title>
    <link href="https://blog.yilin.dev/2019/05/19/Learn-economics-1/"/>
    <id>https://blog.yilin.dev/2019/05/19/Learn-economics-1/</id>
    <published>2019-05-19T11:59:38.273Z</published>
    <updated>2019-05-21T07:57:14.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Economics"><a href="#Economics" class="headerlink" title="Economics"></a>Economics</h3><ul><li>Microeconomics: microeconomics exams the behavior and decisions of individual firms and households and the way they interact in specific industries and markets. We use it to analyze decisions made by individual firms, or to look at how certain factors can affect the market for a specific good.</li><li>Macroeconomics: Macroeconomics focuses on the whole national economy or even the whole world economy. Macroeconomics examines the workings and problems of the whole economy, looking at features such as GDP growth and unemployment. We would use macroeconomics to examine the factors that contribute to a country or region’s overall economic growth, or to determine the cause of economic fluctuations (e.g. recessions).</li></ul><h2 id="The-Central-Idea"><a href="#The-Central-Idea" class="headerlink" title="The Central Idea"></a>The Central Idea</h2><h3 id="Economics-“mantra”"><a href="#Economics-“mantra”" class="headerlink" title="Economics “mantra”"></a>Economics “mantra”</h3><p>People make <strong>choices</strong> with <strong>scarce</strong> resources, and then they <strong>interact</strong> with other people in markets in other places when they make these choices.</p><h3 id="Opportunity-cost"><a href="#Opportunity-cost" class="headerlink" title="Opportunity cost"></a>Opportunity cost</h3><p>The value of the next-best forgone alternative to making a choice. Economists consider this the real cost of a decision.</p><h3 id="Gains-from-trade"><a href="#Gains-from-trade" class="headerlink" title="Gains from trade"></a>Gains from trade</h3><p>Improvements in income, production, or satisfaction owing to the exchange of goods or services.</p><h3 id="Economic-interaction"><a href="#Economic-interaction" class="headerlink" title="Economic interaction"></a>Economic interaction</h3><p>The interaction can lead to the following:</p><ul><li>Specialization: a concentration of production effort on a single specific task.</li><li>Division of labor: the division of production into various parts in which different groups of workers specialize.</li><li>Comparative advantage: a situation in which a person or group can produce one good at a lower opportunity cost than another person or group.</li></ul><h3 id="Economics-Decision-and-the-Role-of-Government"><a href="#Economics-Decision-and-the-Role-of-Government" class="headerlink" title="Economics Decision and the Role of Government"></a>Economics Decision and the Role of Government</h3><ol><li>Predictale policy framework: the government needs to be predictable in its decision-making process.</li><li>Rule of law (e.g. property rights): property rights need to be clearly defined and enforced.</li><li>Reliable on market economy: the government needs to allow the market to determine prices and quantities produced.<ul><li>freely determined prices</li></ul></li><li>Good incentives: the government needs to provide good incentives for economic activity, such as patents to encourage innovation.</li><li>Specific role of government: the government needs to be able to intervene in the case of market failure, when the market would fail to reach the efficient outcome.<ul><li>Market failure</li><li>Government failure</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Video 1A: Welcome to the Principles of Economics</p><p>Video 1B: The Central Idea - Choice, Scarcity, and Interaction</p><p><a href="https://lagunita.stanford.edu/courses/course-v1:HumanitiesSciences+Econ1V+Summer2018/courseware/587753f024b7428db55185117eab48d2/1fda2d9eb33843969449a8ae324dacd4/?child=first" target="_blank" rel="noopener">Principles of Economics(Stanford)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;Economics&quot;&gt;&lt;a href=&quot;#Economics&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="economics" scheme="https://blog.yilin.dev/tags/economics/"/>
    
  </entry>
  
  <entry>
    <title>Learning Compiler 3 Lexical Analysis</title>
    <link href="https://blog.yilin.dev/2019/05/19/Learn-compiler-3/"/>
    <id>https://blog.yilin.dev/2019/05/19/Learn-compiler-3/</id>
    <published>2019-05-19T06:14:33.455Z</published>
    <updated>2019-08-24T16:10:43.043Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h3><p>The input is just a string of characters.</p><p>The goal is to partition input string into substrings.</p><h3 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h3><p>Tokens correspond to sets of strings.</p><ul><li>Identifier: strings of letters or digits, starting with a letter</li><li>Integer: a non-empty string of digits</li><li>Keyword: “else” or “if” or “begin” or …</li><li>Whitespace: a non-empty sequence of blanks, newlines, and tabs</li></ul><h3 id="Token-are-Used-to"><a href="#Token-are-Used-to" class="headerlink" title="Token are Used to"></a>Token are Used to</h3><ul><li>Classify program substrings according to role</li><li>Output of lexical analysis is a stream of tokens…</li><li>Input to the parser</li><li>Parser relies on token distinctions<ul><li>An identifier is treated differently than a keyword</li></ul></li></ul><h3 id="Lexical-analyzer-design"><a href="#Lexical-analyzer-design" class="headerlink" title="Lexical analyzer design"></a>Lexical analyzer design</h3><p>Step 1: Define a finite set of tokens</p><ul><li>Tokens describe all items of interest</li><li>Choice of tokens depends on language, design of parser</li></ul><p>Step 2: Describe which strings belong to each token</p><ul><li>Identifier: strings of letters or digits, starting with a letter</li><li>Integer: a non-empty string of digits</li><li>Keyword: “else” or “if” or “begin” or …</li><li>Whitespace: a non-empty sequence of blanks, newlines, and tabs</li></ul><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Do two things:</p><ol><li>Recognize substrings corresponding to tokens</li><li>Return the value or lexeme of the token<ul><li>The lexeme is the substring</li></ul></li></ol><p>The lexer usually discards “ninteresting” tokens that don’t contribute to parsing.</p><ul><li>Examples: Whitespace, Comments</li></ul><h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p>The goal of lexical analysis is to</p><ul><li>Partition the input string into lexemes</li><li>Identify the token of each lexeme</li></ul><p>Left-to-right scan =&gt; lookahead sometimes required</p><h3 id="Regular-languages"><a href="#Regular-languages" class="headerlink" title="Regular languages"></a>Regular languages</h3><p><em>Def.</em> Let <span>$\Sigma$</span><!-- Has MathJax --> be a set of characters. A language over <span>$\Sigma$</span><!-- Has MathJax --> is a set of strings of characters drawn from <span>$\Sigma$</span><!-- Has MathJax -->.</p><h3 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h3><h3 id="Atomic-Regular-Expressions"><a href="#Atomic-Regular-Expressions" class="headerlink" title="Atomic Regular Expressions"></a>Atomic Regular Expressions</h3><p>Single character: ‘c’ = {“c”}</p><p>Epsilon: <span>$\epsilon$</span><!-- Has MathJax --> = {“”}</p><h3 id="Compound-Regular-Expressions"><a href="#Compound-Regular-Expressions" class="headerlink" title="Compound Regular Expressions"></a>Compound Regular Expressions</h3><p>Union: <span>$A+B = \{s|s\in A\;\text{or}\;s\in B\}$</span><!-- Has MathJax --></p><p>Concatenation: <span>$AB = \{ab|a\in A\;\text{and}\;b\in B\}$</span><!-- Has MathJax --></p><p>Iteration: <span>$A^* = \cup_{i\geq 0}A^i\;\text{where}\;A^i = A...i\;\text{times}...A$</span><!-- Has MathJax --></p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><em>Def.</em> The regular expressions over <span>$\Sigma$</span><!-- Has MathJax --> are the smallest set of expressions including</p><span>$\epsilon$</span><!-- Has MathJax --><span>$&apos;c&apos; \;\text{where}\;c \in \Sigma$</span><!-- Has MathJax --><span>$A+B \;\text{where}\; A,B \;\text{are rexp over}\;\Sigma$</span><!-- Has MathJax --><span>$AB\quad&quot;\;\;\;&quot;\;\;\;&quot;$</span><!-- Has MathJax --><span>$A^* \;\text{where}\; A \;\text{is a rexp over}\;\Sigma$</span><!-- Has MathJax --><h3 id="Syntax-vs-Semantics"><a href="#Syntax-vs-Semantics" class="headerlink" title="Syntax vs. Semantics"></a>Syntax vs. Semantics</h3><span>$L(\epsilon) = \{&quot;&quot;\}$</span><!-- Has MathJax --><span>$L(&apos;c&apos;) = \{&quot;c&quot;\}$</span><!-- Has MathJax --><span>$L(A+B) = L(A) + L(B)$</span><!-- Has MathJax --><span>$L(AB)=\{ab|a\in L(A)\;\text{and}\;b\in L(B)\}$</span><!-- Has MathJax --><span>$L(A^*)= \cup_{i\geq 0}L(A^i)$</span><!-- Has MathJax --><h3 id="Segue"><a href="#Segue" class="headerlink" title="Segue"></a>Segue</h3><p>Keywords: e.g. ‘if’ abbreviates ‘i’’f’</p><p>Integers: Abbreviation: <span>$A^+ = AA^*$</span><!-- Has MathJax --></p><ul><li>a non-empty string of digits</li><li>digit = ‘0’+’1’+’2’+’3’+’4’+’5’+’6’+’7’+’8’+’9’</li><li>integer = digit digit<span>$^*$</span><!-- Has MathJax --></li></ul><p>Identifier: Abbrevation: letter (letter + digit)<span>$^*$</span><!-- Has MathJax --></p><ul><li>strings of letters or digits, starting with a letter</li><li>letter = ‘A’+…+’Z’+’a’+…+ ‘z’</li></ul><p>Whitespace: Abbrevation: <span>$(&apos;\;&apos; + &apos;\n&apos; + &apos;\t&apos;)^+$</span><!-- Has MathJax --></p><ul><li>a non-empty sequence of blanks, newlines, and tabs</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture03.pdf" target="_blank" rel="noopener">Lexical Analysis</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;Lexical-Analysis&quot;&gt;&lt;a href=&quot;#Lexical-Analysis&quot; class=&quot;head
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="Compiler" scheme="https://blog.yilin.dev/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Learning Compiler 2 Language Design</title>
    <link href="https://blog.yilin.dev/2019/05/19/Learn-compiler-2/"/>
    <id>https://blog.yilin.dev/2019/05/19/Learn-compiler-2/</id>
    <published>2019-05-19T05:11:26.857Z</published>
    <updated>2019-05-21T07:54:56.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Programming-Language-Economics"><a href="#Programming-Language-Economics" class="headerlink" title="Programming Language Economics"></a>Programming Language Economics</h3><p>Languages are adopted to fill a void</p><ul><li>Enable a previously difficult/impossible application</li><li>Orthogonal to language design quality (almost)</li></ul><p>Programmer training is the dominant cost</p><ul><li>Languages with many users are replaced rarely</li><li>Popular languages become ossified</li><li>Buteasytostartinanewniche…</li></ul><h3 id="Why-So-Many-Languages"><a href="#Why-So-Many-Languages" class="headerlink" title="Why So Many Languages"></a>Why So Many Languages</h3><p>Application domains have distinctive and conflicting needs</p><h3 id="Language-Evaluation-Criteria"><a href="#Language-Evaluation-Criteria" class="headerlink" title="Language Evaluation Criteria"></a>Language Evaluation Criteria</h3><table><thead><tr><th align="center">Characteristic</th><th align="center">Criteria 1</th><th align="center">Criteria 2</th><th align="center">Criteria 3</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Readability</td><td align="center">Writeability</td><td align="center">Reliability</td></tr><tr><td align="center">Data types</td><td align="center">*</td><td align="center">*</td><td align="center">*</td></tr><tr><td align="center">Abstraction</td><td align="center"></td><td align="center">*</td><td align="center">*</td></tr><tr><td align="center">Type checking</td><td align="center"></td><td align="center"></td><td align="center">*</td></tr><tr><td align="center">Exception handling</td><td align="center"></td><td align="center"></td><td align="center">*</td></tr></tbody></table><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p><strong>Abstraction</strong>:</p><ul><li>Detached from concrete details</li><li>Modes of abstraction:<ul><li>Via languages/compilers: Higher-level code, few machine dependencies</li><li>Via subroutines: Abstract interface to behavior</li><li>Via modules: Export interfaces; hide implementation</li><li>Via abstract data types: Bundle data with its operations</li></ul></li></ul><p><strong>Types</strong>:</p><ul><li>Originally, few types<ul><li>FORTRAN: scalars, arrays</li><li>LISP: no static type distinctions</li></ul></li><li>Realization: Types help<ul><li>Allow the programmer to express abstraction</li><li>Allow the compiler to check against many frequent errors</li><li>Sometimes to the point that programs are guaranteed “safe”</li></ul></li><li>More recently<ul><li>Lots of interest in types</li><li>Experiments with various forms of parameterization</li><li>Best developed in functional programming</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture02.pdf" target="_blank" rel="noopener">Language Design</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;Programming-Language-Economics&quot;&gt;&lt;a href=&quot;#Programming-Lan
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="Compiler" scheme="https://blog.yilin.dev/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>Learning Compiler 1 Overview</title>
    <link href="https://blog.yilin.dev/2019/05/18/Learn-complier-1/"/>
    <id>https://blog.yilin.dev/2019/05/18/Learn-complier-1/</id>
    <published>2019-05-18T04:54:01.472Z</published>
    <updated>2019-05-21T07:54:23.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Strategies"><a href="#Strategies" class="headerlink" title="Strategies"></a>Strategies</h3><ul><li>Interpreters(slightly order)</li><li>Compilers(slightly newer)</li></ul><h3 id="Difference-Between-Interpreters-and-Compilers"><a href="#Difference-Between-Interpreters-and-Compilers" class="headerlink" title="Difference Between Interpreters and Compilers"></a>Difference Between Interpreters and Compilers</h3><ul><li>Interpreters run programs “as is”: little or no preprocessing</li><li>Compilers do extensive preprocessing</li></ul><h3 id="Language-Implementations"><a href="#Language-Implementations" class="headerlink" title="Language Implementations"></a>Language Implementations</h3><ul><li>Low level: C/C++</li><li>Higher level: Python</li><li>Interpreter + “Just In Time”(JIT) compiler: Java</li></ul><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>FORTRAN I</p><h3 id="Struture-of-Compiler"><a href="#Struture-of-Compiler" class="headerlink" title="Struture of Compiler"></a>Struture of Compiler</h3><ol><li>Lexical analysis</li><li>Parsing</li><li>Semantic analysis</li><li>Optimization</li><li>Code generation</li></ol><ul><li><p>Lexical analysis: First step: recognize words. Divides program text into “words” or “tokens”.</p></li><li><p>Parsing: Understand sentence structure. Parsing = Diagramming Sentences(a tree).</p></li><li><p>Semantic analysis: Understand “meaning”. Compilers perform limited analysis to catch inconsistencies, and many semantic checks besides variable bindings.</p></li><li><p>Optimization: Automatically modify programs to run faster, use less memory and in general, conserve some resource.</p></li><li><p>Code generation: Usually produces assembly code. A translation into another language.</p></li></ul><h3 id="Intermediate-Languages-IL"><a href="#Intermediate-Languages-IL" class="headerlink" title="Intermediate Languages(IL)"></a>Intermediate Languages(IL)</h3><p>Many compilers perform translations between successive intermediate forms:</p><ul><li>All but first and last are intermediate languages internal to the compiler</li><li>Typically there is 1 IL</li></ul><p>IL’s generally ordered in descending level of abstraction</p><ul><li>Highest is source</li><li>Lowest is assembly</li></ul><p>IL’s are useful because lower levels expose features hidden by higher levels</p><ul><li>registers</li><li>memory layout</li><li>etc.</li></ul><p>But lower levels obscure high-level meaning</p><h3 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h3><p>Language design has big impact on compiler</p><ul><li>Determines what is easy and hard to compile</li><li>Course theme: many trade-offs in language design</li></ul><h3 id="Today’s-Compiler"><a href="#Today’s-Compiler" class="headerlink" title="Today’s Compiler"></a>Today’s Compiler</h3><p>The proportions have changed since FORTRAN</p><ul><li>Early: lexing, parsing most complex, expensive</li><li>Today: optimization dominates all other phases, lexing and parsing are cheap</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture01.pdf" target="_blank" rel="noopener">Overview</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Note&quot;&gt;&lt;a href=&quot;#Note&quot; class=&quot;headerlink&quot; title=&quot;Note&quot;&gt;&lt;/a&gt;Note&lt;/h2&gt;&lt;h3 id=&quot;Strategies&quot;&gt;&lt;a href=&quot;#Strategies&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="学不死就往死里学" scheme="https://blog.yilin.dev/categories/%E5%AD%A6%E4%B8%8D%E6%AD%BB%E5%B0%B1%E5%BE%80%E6%AD%BB%E9%87%8C%E5%AD%A6/"/>
    
    
      <category term="Learning" scheme="https://blog.yilin.dev/tags/Learning/"/>
    
      <category term="Compiler" scheme="https://blog.yilin.dev/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>第一条博客</title>
    <link href="https://blog.yilin.dev/2019/05/06/First-Blog/"/>
    <id>https://blog.yilin.dev/2019/05/06/First-Blog/</id>
    <published>2019-05-06T13:26:07.026Z</published>
    <updated>2019-05-19T05:11:51.115Z</updated>
    
    <content type="html"><![CDATA[<p>我如果不发一条这么无聊的博客当做第一条博客，那么网站就无法生成……嗯回头我再写一篇详细介绍我的创建过程吧。晚安。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我如果不发一条这么无聊的博客当做第一条博客，那么网站就无法生成……嗯回头我再写一篇详细介绍我的创建过程吧。晚安。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Chaos" scheme="https://blog.yilin.dev/categories/Chaos/"/>
    
    
      <category term="Boring" scheme="https://blog.yilin.dev/tags/Boring/"/>
    
      <category term="First" scheme="https://blog.yilin.dev/tags/First/"/>
    
  </entry>
  
</feed>
