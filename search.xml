<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learning Compiler 3</title>
      <link href="/2019/05/19/Learn-compiler-3/"/>
      <url>/2019/05/19/Learn-compiler-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Language-Design"><a href="#Language-Design" class="headerlink" title="Language Design"></a>Language Design</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h4><p>The input is just a string of characters.</p><p>The goal is to partition input string into substrings.</p><h4 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h4><p>Tokens correspond to sets of strings.</p><ul><li>Identifier: strings of letters or digits, starting with a letter</li><li>Integer: a non-empty string of digits</li><li>Keyword: “else” or “if” or “begin” or …</li><li>Whitespace: a non-empty sequence of blanks, newlines, and tabs</li></ul><h4 id="Token-are-Used-to"><a href="#Token-are-Used-to" class="headerlink" title="Token are Used to"></a>Token are Used to</h4><ul><li>Classify program substrings according to role</li><li>Output of lexical analysis is a stream of tokens…</li><li>Input to the parser</li><li>Parser relies on token distinctions<ul><li>An identifier is treated differently than a keyword</li></ul></li></ul><h4 id="Lexical-analyzer-design"><a href="#Lexical-analyzer-design" class="headerlink" title="Lexical analyzer design"></a>Lexical analyzer design</h4><p>Step 1: Define a finite set of tokens</p><ul><li>Tokens describe all items of interest</li><li>Choice of tokens depends on language, design of parser</li></ul><p>Step 2: Describe which strings belong to each token</p><ul><li>Identifier: strings of letters or digits, starting with a letter</li><li>Integer: a non-empty string of digits</li><li>Keyword: “else” or “if” or “begin” or …</li><li>Whitespace: a non-empty sequence of blanks, newlines, and tabs</li></ul><h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p>Do two things:</p><ol><li>Recognizesubstringscorrespondingtotokens</li><li>Return the value or lexeme of the token<ul><li>The lexeme is the substring</li></ul></li></ol><p>The lexer usually discards “ninteresting” tokens that don’t contribute to parsing.</p><ul><li>Examples: Whitespace, Comments</li></ul><h4 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h4><p>The goal of lexical analysis is to</p><ul><li>Partition the input string into lexemes</li><li>Identify the token of each lexeme</li></ul><p>Left-to-right scan =&gt; lookahead sometimes required</p><h4 id="Regular-languages"><a href="#Regular-languages" class="headerlink" title="Regular languages"></a>Regular languages</h4><p><em>Def.</em> Let $\Sigma$ be a set of characters. A language over $\Sigma$ is a set of strings of characters drawn from $\Sigma$</p><h4 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h4><h5 id="Atomic-Regular-Expressions"><a href="#Atomic-Regular-Expressions" class="headerlink" title="Atomic Regular Expressions"></a>Atomic Regular Expressions</h5><p>Single character: ‘c’ = {“c”}</p><p>Epsilon: $\epsilon$ = {“”}</p><h5 id="Compound-Regular-Expressions"><a href="#Compound-Regular-Expressions" class="headerlink" title="Compound Regular Expressions"></a>Compound Regular Expressions</h5><p>Union: $A+B = {s|s\in A\;\text{or}\;s\in B}$</p><p>Concatenation: $AB = {ab|a\in A\;\text{and}\;b\in B}$</p><p>Iteration: $A^* = \cup_{i\geq 0}A^i\;\text{where}\;A^i = A…i\;\text{times}…A$</p><h4 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h4><p><em>Def.</em> The regular expressions over $\Sigma$ are the smallest set of expressions including</p><p>$\epsilon$</p><p>$’c’ \;\text{where}\;c \in \Sigma$</p><p>$A+B \;\text{where}\; A,B \;\text{are rexp over}\;\Sigma$</p><p>$AB\quad”\;\;\;”\;\;\;”$</p><p>$A^* \;\text{where}\; A \;\text{is a rexp over}\;\Sigma$</p><h4 id="Syntax-vs-Semantics"><a href="#Syntax-vs-Semantics" class="headerlink" title="Syntax vs. Semantics"></a>Syntax vs. Semantics</h4><p>$L(\epsilon) = {“”}$</p><p>$L(‘c’) = {“c”}$</p><p>$L(A+B) = L(A) + L(B)$</p><p>$L(AB)={ab|a\in L(A)\;\text{and}\;b\in L(B)}$</p><p>$L(A^*)= \cup_{i\geq 0}L(A^i)$</p><h4 id="Segue"><a href="#Segue" class="headerlink" title="Segue"></a>Segue</h4><p>Keywords: e.g. ‘if’ abbreviates ‘i’’f’</p><p>Integers: Abbreviation: $A^+ = AA^*$</p><ul><li>a non-empty string of digits</li><li>digit = ‘0’+’1’+’2’+’3’+’4’+’5’+’6’+’7’+’8’+’9’ </li><li>integer = digit digit*</li></ul><p>Identifier: Abbrevation: letter (letter + digit)$^*$</p><ul><li>strings of letters or digits, starting with a letter</li><li>letter = ‘A’+…+’Z’+’a’+…+ ‘z’</li></ul><p>Whitespace: Abbrevation: $(‘ ‘ + ‘\n’ + ‘\t’)^+$</p><ul><li>a non-empty sequence of blanks, newlines, and tabs</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture03.pdf" target="_blank" rel="noopener">Lexical Analysis</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Compiler 2</title>
      <link href="/2019/05/19/Learn-compiler-2/"/>
      <url>/2019/05/19/Learn-compiler-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Language-Design"><a href="#Language-Design" class="headerlink" title="Language Design"></a>Language Design</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="Programming-Language-Economics"><a href="#Programming-Language-Economics" class="headerlink" title="Programming Language Economics"></a>Programming Language Economics</h4><p>Languages are adopted to fill a void</p><ul><li>Enable a previously difficult/impossible application</li><li>Orthogonal to language design quality (almost)</li></ul><p>Programmer training is the dominant cost</p><ul><li>Languages with many users are replaced rarely</li><li>Popular languages become ossified</li><li>Buteasytostartinanewniche…</li></ul><h4 id="Why-So-Many-Languages"><a href="#Why-So-Many-Languages" class="headerlink" title="Why So Many Languages"></a>Why So Many Languages</h4><p>Application domains have distinctive and conflicting needs</p><h4 id="Language-Evaluation-Criteria"><a href="#Language-Evaluation-Criteria" class="headerlink" title="Language Evaluation Criteria"></a>Language Evaluation Criteria</h4><table><thead><tr><th style="text-align:center">Characteristic</th><th style="text-align:center">Criteria 1</th><th style="text-align:center">Criteria 2</th><th style="text-align:center">Criteria 3</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">Readability</td><td style="text-align:center">Writeability</td><td style="text-align:center">Reliability</td></tr><tr><td style="text-align:center">Data types</td><td style="text-align:center">*</td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">Abstraction</td><td style="text-align:center"></td><td style="text-align:center">*</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">Type checking</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">Exception handling</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">*</td></tr></tbody></table><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p><strong>Abstraction</strong>:</p><ul><li>Detached from concrete details</li><li>Modes of abstraction:<ul><li>Via languages/compilers: Higher-level code, few machine dependencies</li><li>Via subroutines: Abstract interface to behavior</li><li>Via modules: Export interfaces; hide implementation</li><li>Via abstract data types: Bundle data with its operations</li></ul></li></ul><p><strong>Types</strong>:</p><ul><li>Originally, few types<ul><li>FORTRAN: scalars, arrays</li><li>LISP: no static type distinctions</li></ul></li><li>Realization: Types help<ul><li>Allow the programmer to express abstraction</li><li>Allow the compiler to check against many frequent errors</li><li>Sometimes to the point that programs are guaranteed “safe”</li></ul></li><li>More recently<ul><li>Lots of interest in types</li><li>Experiments with various forms of parameterization</li><li>Best developed in functional programming</li></ul></li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture02.pdf" target="_blank" rel="noopener">Language Design</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Compiler 1</title>
      <link href="/2019/05/18/Learn-complier-1/"/>
      <url>/2019/05/18/Learn-complier-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="Strategies"><a href="#Strategies" class="headerlink" title="Strategies"></a>Strategies</h4><ul><li>Interpreters(slightly order)</li><li>Compilers(slightly newer)</li></ul><h4 id="Difference-Between-Interpreters-and-Compilers"><a href="#Difference-Between-Interpreters-and-Compilers" class="headerlink" title="Difference Between Interpreters and Compilers"></a>Difference Between Interpreters and Compilers</h4><ul><li>Interpreters run programs “as is”: little or no preprocessing</li><li>Compilers do extensive preprocessing</li></ul><h4 id="Language-Implementations"><a href="#Language-Implementations" class="headerlink" title="Language Implementations"></a>Language Implementations</h4><ul><li>Low level: C/C++</li><li>Higher level: Python</li><li>Interpreter + “Just In Time”(JIT) compiler: Java</li></ul><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>FORTRAN I</p><h4 id="Struture-of-Compiler"><a href="#Struture-of-Compiler" class="headerlink" title="Struture of Compiler"></a>Struture of Compiler</h4><ol><li>Lexical analysis</li><li>Parsing</li><li>Semantic analysis</li><li>Optimization</li><li>Code generation</li></ol><ul><li><p>Lexical analysis: First step: recognize words. Divides program text into “words” or “tokens”.</p></li><li><p>Parsing: Understand sentence structure. Parsing = Diagramming Sentences(a tree).</p></li><li><p>Semantic analysis: Understand “meaning”. Compilers perform limited analysis to catch inconsistencies, and many semantic checks besides variable bindings.</p></li><li><p>Optimization: Automatically modify programs to run faster, use less memory and in general, conserve some resource.</p></li><li><p>Code generation: Usually produces assembly code. A translation into another language.</p></li></ul><h4 id="Intermediate-Languages-IL"><a href="#Intermediate-Languages-IL" class="headerlink" title="Intermediate Languages(IL)"></a>Intermediate Languages(IL)</h4><p>Many compilers perform translations between successive intermediate forms:</p><ul><li>All but first and last are intermediate languages internal to the compiler</li><li>Typically there is 1 IL</li></ul><p>IL’s generally ordered in descending level of abstraction</p><ul><li>Highest is source</li><li>Lowest is assembly</li></ul><p>IL’s are useful because lower levels expose features hidden by higher levels</p><ul><li>registers</li><li>memory layout</li><li>etc.</li></ul><p>But lower levels obscure high-level meaning</p><h4 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h4><p>Language design has big impact on compiler</p><ul><li>Determines what is easy and hard to compile</li><li>Course theme: many trade-offs in language design</li></ul><h4 id="Today’s-Compiler"><a href="#Today’s-Compiler" class="headerlink" title="Today’s Compiler"></a>Today’s Compiler</h4><p>The proportions have changed since FORTRAN</p><ul><li>Early: lexing, parsing most complex, expensive</li><li>Today: optimization dominates all other phases, lexing and parsing are cheap</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture01.pdf" target="_blank" rel="noopener">Overview</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一条博客</title>
      <link href="/2019/05/06/First-Blog/"/>
      <url>/2019/05/06/First-Blog/</url>
      
        <content type="html"><![CDATA[<p>我如果不发一条这么无聊的博客当做第一条博客，那么网站就无法生成……嗯回头我再写一篇详细介绍我的创建过程吧。晚安。</p>]]></content>
      
      
      <categories>
          
          <category> Chaos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boring </tag>
            
            <tag> First </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
