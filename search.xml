<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Learning Compiler 4 Finite Automata</title>
      <link href="/2019/05/21/Learn-compiler-4/"/>
      <url>/2019/05/21/Learn-compiler-4/</url>
      
        <content type="html"><![CDATA[<h2 id="Finite-Automata"><a href="#Finite-Automata" class="headerlink" title="Finite Automata"></a>Finite Automata</h2><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><h4 id="Specifying-Lexical-Structure-Using-Regular-Expressions"><a href="#Specifying-Lexical-Structure-Using-Regular-Expressions" class="headerlink" title="Specifying Lexical Structure Using Regular Expressions"></a>Specifying Lexical Structure Using Regular Expressions</h4><p>Union: <span>$A|B\equiv A + B$</span><!-- Has MathJax --><br>Option: <span>$A + \epsilon \equiv A?$</span><!-- Has MathJax --><br>Range: <span>$&apos;a&apos;+&apos;b&apos;+\dots+&apos;z&apos;\equiv [a-z]$</span><!-- Has MathJax --><br>Excluded range: complement of <span>$[a-z] \equiv [\^a-z]$</span><!-- Has MathJax --></p><h4 id="Regular-Expressions-gt-Lexical-Spec"><a href="#Regular-Expressions-gt-Lexical-Spec" class="headerlink" title="Regular Expressions =&gt; Lexical Spec."></a>Regular Expressions =&gt; Lexical Spec.</h4><ol><li>Write a rexp for the lexemes of each token</li><li>Construct <span>$R$</span><!-- Has MathJax -->, matching all lexemes for all tokens<ul><li><span>$R = Keyword + Identifier + Number + \dots \\ = R_1 + R_2 + \dots$</span><!-- Has MathJax --></li></ul></li><li>Let input be <span>$x_1\dots x_n$</span><!-- Has MathJax --><ul><li>For <span>$1 \leq i \leq n$</span><!-- Has MathJax --> check <span>$x_1\dots x_i\in L(R)$</span><!-- Has MathJax --></li></ul></li><li>If success, then we know that <span>$x_1\dots x_i\in L(R_j)$</span><!-- Has MathJax --> for some <span>$j$</span><!-- Has MathJax --></li><li>Remove <span>$x_1\dots x_i$</span><!-- Has MathJax --> from input and go to (3)</li></ol><h4 id="Ambiguities"><a href="#Ambiguities" class="headerlink" title="Ambiguities"></a>Ambiguities</h4><p>Rule: Pick longest possible string in <span>$L(R)$</span><!-- Has MathJax --></p><p>Rule: Use rule listed first</p><h4 id="Error-handling"><a href="#Error-handling" class="headerlink" title="Error handling"></a>Error handling</h4><p>No rule matches a prefix of input</p><p>Solution:</p><ul><li>Write a rule matching all “bad” strings</li><li>Put it last (lowest priority)</li></ul><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>Regular expressions provide a concise notation for string patterns</p><p>Use in lexical analysis requires small extensions</p><ul><li>To resolve ambiguities</li><li>To handle errors</li></ul><p>Good algorithms known</p><ul><li>Require only single pass over the input</li><li>Few operations per character (table lookup)</li></ul><h4 id="Finite-Automata-1"><a href="#Finite-Automata-1" class="headerlink" title="Finite Automata"></a>Finite Automata</h4><p>Regular expressions = specification</p><p>Finite automata = implementation</p><p>A finite automaton consists of –  An input alphabet <span>$\Epsilon$</span><!-- Has MathJax --></p><ul><li>A set of states <span>$S$</span><!-- Has MathJax --></li><li>A start state <span>$n$</span><!-- Has MathJax --></li><li>A set of accepting states <span>$F\subseteq S$</span><!-- Has MathJax --></li><li>A set of transitions state <span>$\rightarrow^{\text{input}}$</span><!-- Has MathJax --> state</li></ul><p>Transition: <span>$s_1 \rightarrow^{a} s_2$</span><!-- Has MathJax --></p><p>Is read: In state <span>$s_1$</span><!-- Has MathJax --> on input “a” go to state <span>$s_2$</span><!-- Has MathJax --></p><p>If end of input and in accepting state =&gt; accept</p><p>Otherwise =&gt; reject</p><h4 id="Finite-Automata-State-Graphs"><a href="#Finite-Automata-State-Graphs" class="headerlink" title="Finite Automata State Graphs"></a>Finite Automata State Graphs</h4><p><img src="./figures/FASG.png" alt="Finite Automata State Graphs"></p><h4 id="Epsilon-Moves"><a href="#Epsilon-Moves" class="headerlink" title="Epsilon Moves"></a>Epsilon Moves</h4><span>$\epsilon$</span><!-- Has MathJax -->-moves<p><img src="./figures/epsilon-move.png" alt="Epsilon Moves"></p><p>Machine can move from state A to state B without reading input</p><h4 id="Deterministic-and-Nondeterministic-Automata"><a href="#Deterministic-and-Nondeterministic-Automata" class="headerlink" title="Deterministic and Nondeterministic Automata"></a>Deterministic and Nondeterministic Automata</h4><p>Deterministic Finite Automata (DFA)</p><ul><li>One transition per input per state</li><li>No <span>$\epsilon$</span><!-- Has MathJax -->-moves</li></ul><p>Nondeterministic Finite Automata (NFA)</p><ul><li>Can have multiple transitions for one input in a<br>given state</li><li>Can have <span>$\epsilon$</span><!-- Has MathJax -->-moves</li></ul><h4 id="Execution-of-Finite-Automata"><a href="#Execution-of-Finite-Automata" class="headerlink" title="Execution of Finite Automata"></a>Execution of Finite Automata</h4><p>A DFA can take only one path through the state graph</p><ul><li>Completely determined by input</li></ul><p>NFAs can choose</p><ul><li>Whether to make <span>$\epsilon$</span><!-- Has MathJax -->-moves</li><li>Which of multiple transitions for a single input to take</li></ul><h4 id="Acceptance-of-NFAs"><a href="#Acceptance-of-NFAs" class="headerlink" title="Acceptance of NFAs"></a>Acceptance of NFAs</h4><p>An NFA can get into multiple states</p><p>Rule: NFA accepts if it can get to a final state</p><h4 id="NFA-vs-DFA"><a href="#NFA-vs-DFA" class="headerlink" title="NFA vs. DFA"></a>NFA vs. DFA</h4><p>NFAs and DFAs recognize the same set of languages (regular languages)</p><p>DFAs are faster to execute</p><ul><li>No choices to consider</li></ul><p>For a given language NFA can be simpler than DFA</p><p>DFA can be exponentially larger than NFA</p><h4 id="Regular-Expressions-to-Finite-Automata"><a href="#Regular-Expressions-to-Finite-Automata" class="headerlink" title="Regular Expressions to Finite Automata"></a>Regular Expressions to Finite Automata</h4><p>High-level sketch:</p><p>Lexical Specification -&gt; Regular Expressions -&gt; NFA -&gt; DFA -&gt; Table-driven Implementation of DFA</p><h4 id="Regular-Expressions-to-NFA"><a href="#Regular-Expressions-to-NFA" class="headerlink" title="Regular Expressions to NFA"></a>Regular Expressions to NFA</h4><p><img src="./figures/rexp2nfa1.png" alt="Regular Expressions to NFA 1"></p><p><img src="./figures/rexp2nfa2.png" alt="Regular Expressions to NFA 1"></p><p><img src="./figures/rexp2nfa3.png" alt="Regular Expressions to NFA 1"></p><h4 id="NFA-to-DFA-The-Trick"><a href="#NFA-to-DFA-The-Trick" class="headerlink" title="NFA to DFA: The Trick"></a>NFA to DFA: The Trick</h4><p>Simulate the NFA</p><p>Each state of DFA = a non-empty subset of states of the NFA</p><p>Start state = the set of NFA states reachable through <span>$\epsilon$</span><!-- Has MathJax -->-moves from NFA start state</p><p>Add a transition <span>$S \rightarrow^a S&apos;$</span><!-- Has MathJax --> to DFA iff <span>$S&apos;$</span><!-- Has MathJax --> is the set of NFA states reachable from any<br>state in <span>$S$</span><!-- Has MathJax --> after seeing the input <span>$a$</span><!-- Has MathJax -->, considering <span>$\epsilon$</span><!-- Has MathJax -->-moves as well</p><h4 id="NFA-to-DFA-Remark"><a href="#NFA-to-DFA-Remark" class="headerlink" title="NFA to DFA. Remark"></a>NFA to DFA. Remark</h4><p>An NFA may be in many states at any time</p><p>If there are N states, the NFA must be in some subset of those N states</p><p>How many subsets are there?</p><ul><li><span>$2^N - 1$</span><!-- Has MathJax --> = finitely many</li></ul><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><p><img src="./figures/nfa2dfa_example.png" alt="NFA to DFA Example"></p><h4 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h4><p>A DFA can be implemented by a 2D table T</p><ul><li>One dimension is “states”</li><li>Other dimension is “input symbol”</li><li>For every transition <span>$S_i \rightarrow^a S_k$</span><!-- Has MathJax --> define <span>$T[i, a] = k$</span><!-- Has MathJax --></li></ul><p>DFA “execution”</p><ul><li>If in state <span>$S_i$</span><!-- Has MathJax --> and input <span>$a$</span><!-- Has MathJax -->, read <span>$T[i, a] = k$</span><!-- Has MathJax --> and skip to state <span>$S_k$</span><!-- Has MathJax --></li><li>Very efficient</li></ul><p>NFA -&gt; DFA conversion is at the heart of tools such as flex</p><p>DFAs can be huge</p><p>In practice, flex-like tools trade off speed for space in the choice of NFA and DFA representations</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture04.pdf" target="_blank" rel="noopener">Finite Automata</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Economics 1 Introduction</title>
      <link href="/2019/05/19/Learn-economics-1/"/>
      <url>/2019/05/19/Learn-economics-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Economics"><a href="#Economics" class="headerlink" title="Economics"></a>Economics</h3><ul><li>Microeconomics: microeconomics exams the behavior and decisions of individual firms and households and the way they interact in specific industries and markets. We use it to analyze decisions made by individual firms, or to look at how certain factors can affect the market for a specific good.</li><li>Macroeconomics: Macroeconomics focuses on the whole national economy or even the whole world economy. Macroeconomics examines the workings and problems of the whole economy, looking at features such as GDP growth and unemployment. We would use macroeconomics to examine the factors that contribute to a country or region’s overall economic growth, or to determine the cause of economic fluctuations (e.g. recessions).</li></ul><h2 id="The-Central-Idea"><a href="#The-Central-Idea" class="headerlink" title="The Central Idea"></a>The Central Idea</h2><h3 id="Economics-“mantra”"><a href="#Economics-“mantra”" class="headerlink" title="Economics “mantra”"></a>Economics “mantra”</h3><p>People make <strong>choices</strong> with <strong>scarce</strong> resources, and then they <strong>interact</strong> with other people in markets in other places when they make these choices.</p><h3 id="Opportunity-cost"><a href="#Opportunity-cost" class="headerlink" title="Opportunity cost"></a>Opportunity cost</h3><p>The value of the next-best forgone alternative to making a choice. Economists consider this the real cost of a decision.</p><h3 id="Gains-from-trade"><a href="#Gains-from-trade" class="headerlink" title="Gains from trade"></a>Gains from trade</h3><p>Improvements in income, production, or satisfaction owing to the exchange of goods or services.</p><h3 id="Economic-interaction"><a href="#Economic-interaction" class="headerlink" title="Economic interaction"></a>Economic interaction</h3><p>The interaction can lead to the following:</p><ul><li>Specialization: a concentration of production effort on a single specific task.</li><li>Division of labor: the division of production into various parts in which different groups of workers specialize.</li><li>Comparative advantage: a situation in which a person or group can produce one good at a lower opportunity cost than another person or group.</li></ul><h3 id="Economics-Decision-and-the-Role-of-Government"><a href="#Economics-Decision-and-the-Role-of-Government" class="headerlink" title="Economics Decision and the Role of Government"></a>Economics Decision and the Role of Government</h3><ol><li>Predictale policy framework: the government needs to be predictable in its decision-making process.</li><li>Rule of law (e.g. property rights): property rights need to be clearly defined and enforced.</li><li>Reliable on market economy: the government needs to allow the market to determine prices and quantities produced.<ul><li>freely determined prices</li></ul></li><li>Good incentives: the government needs to provide good incentives for economic activity, such as patents to encourage innovation.</li><li>Specific role of government: the government needs to be able to intervene in the case of market failure, when the market would fail to reach the efficient outcome.<ul><li>Market failure</li><li>Government failure</li></ul></li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Video 1A: Welcome to the Principles of Economics</p><p>Video 1B: The Central Idea - Choice, Scarcity, and Interaction</p><p><a href="https://lagunita.stanford.edu/courses/course-v1:HumanitiesSciences+Econ1V+Summer2018/courseware/587753f024b7428db55185117eab48d2/1fda2d9eb33843969449a8ae324dacd4/?child=first" target="_blank" rel="noopener">Principles of Economics(Stanford)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> economics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Compiler 3 Lexical Analysis</title>
      <link href="/2019/05/19/Learn-compiler-3/"/>
      <url>/2019/05/19/Learn-compiler-3/</url>
      
        <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h3><p>The input is just a string of characters.</p><p>The goal is to partition input string into substrings.</p><h3 id="Tokens"><a href="#Tokens" class="headerlink" title="Tokens"></a>Tokens</h3><p>Tokens correspond to sets of strings.</p><ul><li>Identifier: strings of letters or digits, starting with a letter</li><li>Integer: a non-empty string of digits</li><li>Keyword: “else” or “if” or “begin” or …</li><li>Whitespace: a non-empty sequence of blanks, newlines, and tabs</li></ul><h3 id="Token-are-Used-to"><a href="#Token-are-Used-to" class="headerlink" title="Token are Used to"></a>Token are Used to</h3><ul><li>Classify program substrings according to role</li><li>Output of lexical analysis is a stream of tokens…</li><li>Input to the parser</li><li>Parser relies on token distinctions<ul><li>An identifier is treated differently than a keyword</li></ul></li></ul><h3 id="Lexical-analyzer-design"><a href="#Lexical-analyzer-design" class="headerlink" title="Lexical analyzer design"></a>Lexical analyzer design</h3><p>Step 1: Define a finite set of tokens</p><ul><li>Tokens describe all items of interest</li><li>Choice of tokens depends on language, design of parser</li></ul><p>Step 2: Describe which strings belong to each token</p><ul><li>Identifier: strings of letters or digits, starting with a letter</li><li>Integer: a non-empty string of digits</li><li>Keyword: “else” or “if” or “begin” or …</li><li>Whitespace: a non-empty sequence of blanks, newlines, and tabs</li></ul><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><p>Do two things:</p><ol><li>Recognizesubstringscorrespondingtotokens</li><li>Return the value or lexeme of the token<ul><li>The lexeme is the substring</li></ul></li></ol><p>The lexer usually discards “ninteresting” tokens that don’t contribute to parsing.</p><ul><li>Examples: Whitespace, Comments</li></ul><h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p>The goal of lexical analysis is to</p><ul><li>Partition the input string into lexemes</li><li>Identify the token of each lexeme</li></ul><p>Left-to-right scan =&gt; lookahead sometimes required</p><h3 id="Regular-languages"><a href="#Regular-languages" class="headerlink" title="Regular languages"></a>Regular languages</h3><p><em>Def.</em> Let <span>$\Sigma$</span><!-- Has MathJax --> be a set of characters. A language over <span>$\Sigma$</span><!-- Has MathJax --> is a set of strings of characters drawn from <span>$\Sigma$</span><!-- Has MathJax -->.</p><h3 id="Regular-Expressions"><a href="#Regular-Expressions" class="headerlink" title="Regular Expressions"></a>Regular Expressions</h3><h3 id="Atomic-Regular-Expressions"><a href="#Atomic-Regular-Expressions" class="headerlink" title="Atomic Regular Expressions"></a>Atomic Regular Expressions</h3><p>Single character: ‘c’ = {“c”}</p><p>Epsilon: <span>$\epsilon$</span><!-- Has MathJax --> = {“”}</p><h3 id="Compound-Regular-Expressions"><a href="#Compound-Regular-Expressions" class="headerlink" title="Compound Regular Expressions"></a>Compound Regular Expressions</h3><p>Union: <span>$A+B = \{s|s\in A\;\text{or}\;s\in B\}$</span><!-- Has MathJax --></p><p>Concatenation: <span>$AB = \{ab|a\in A\;\text{and}\;b\in B\}$</span><!-- Has MathJax --></p><p>Iteration: <span>$A^* = \cup_{i\geq 0}A^i\;\text{where}\;A^i = A...i\;\text{times}...A$</span><!-- Has MathJax --></p><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p><em>Def.</em> The regular expressions over <span>$\Sigma$</span><!-- Has MathJax --> are the smallest set of expressions including</p><span>$\epsilon$</span><!-- Has MathJax --><span>$&apos;c&apos; \;\text{where}\;c \in \Sigma$</span><!-- Has MathJax --><span>$A+B \;\text{where}\; A,B \;\text{are rexp over}\;\Sigma$</span><!-- Has MathJax --><span>$AB\quad&quot;\;\;\;&quot;\;\;\;&quot;$</span><!-- Has MathJax --><span>$A^* \;\text{where}\; A \;\text{is a rexp over}\;\Sigma$</span><!-- Has MathJax --><h3 id="Syntax-vs-Semantics"><a href="#Syntax-vs-Semantics" class="headerlink" title="Syntax vs. Semantics"></a>Syntax vs. Semantics</h3><span>$L(\epsilon) = \{&quot;&quot;\}$</span><!-- Has MathJax --><span>$L(&apos;c&apos;) = \{&quot;c&quot;\}$</span><!-- Has MathJax --><span>$L(A+B) = L(A) + L(B)$</span><!-- Has MathJax --><span>$L(AB)=\{ab|a\in L(A)\;\text{and}\;b\in L(B)\}$</span><!-- Has MathJax --><span>$L(A^*)= \cup_{i\geq 0}L(A^i)$</span><!-- Has MathJax --><h3 id="Segue"><a href="#Segue" class="headerlink" title="Segue"></a>Segue</h3><p>Keywords: e.g. ‘if’ abbreviates ‘i’’f’</p><p>Integers: Abbreviation: <span>$A^+ = AA^*$</span><!-- Has MathJax --></p><ul><li>a non-empty string of digits</li><li>digit = ‘0’+’1’+’2’+’3’+’4’+’5’+’6’+’7’+’8’+’9’</li><li>integer = digit digit<span>$^*$</span><!-- Has MathJax --></li></ul><p>Identifier: Abbrevation: letter (letter + digit)<span>$^*$</span><!-- Has MathJax --></p><ul><li>strings of letters or digits, starting with a letter</li><li>letter = ‘A’+…+’Z’+’a’+…+ ‘z’</li></ul><p>Whitespace: Abbrevation: <span>$(&apos;\;&apos; + &apos;\n&apos; + &apos;\t&apos;)^+$</span><!-- Has MathJax --></p><ul><li>a non-empty sequence of blanks, newlines, and tabs</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture03.pdf" target="_blank" rel="noopener">Lexical Analysis</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Compiler 2 Language Design</title>
      <link href="/2019/05/19/Learn-compiler-2/"/>
      <url>/2019/05/19/Learn-compiler-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Programming-Language-Economics"><a href="#Programming-Language-Economics" class="headerlink" title="Programming Language Economics"></a>Programming Language Economics</h3><p>Languages are adopted to fill a void</p><ul><li>Enable a previously difficult/impossible application</li><li>Orthogonal to language design quality (almost)</li></ul><p>Programmer training is the dominant cost</p><ul><li>Languages with many users are replaced rarely</li><li>Popular languages become ossified</li><li>Buteasytostartinanewniche…</li></ul><h3 id="Why-So-Many-Languages"><a href="#Why-So-Many-Languages" class="headerlink" title="Why So Many Languages"></a>Why So Many Languages</h3><p>Application domains have distinctive and conflicting needs</p><h3 id="Language-Evaluation-Criteria"><a href="#Language-Evaluation-Criteria" class="headerlink" title="Language Evaluation Criteria"></a>Language Evaluation Criteria</h3><table><thead><tr><th align="center">Characteristic</th><th align="center">Criteria 1</th><th align="center">Criteria 2</th><th align="center">Criteria 3</th></tr></thead><tbody><tr><td align="center"></td><td align="center">Readability</td><td align="center">Writeability</td><td align="center">Reliability</td></tr><tr><td align="center">Data types</td><td align="center">*</td><td align="center">*</td><td align="center">*</td></tr><tr><td align="center">Abstraction</td><td align="center"></td><td align="center">*</td><td align="center">*</td></tr><tr><td align="center">Type checking</td><td align="center"></td><td align="center"></td><td align="center">*</td></tr><tr><td align="center">Exception handling</td><td align="center"></td><td align="center"></td><td align="center">*</td></tr></tbody></table><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p><strong>Abstraction</strong>:</p><ul><li>Detached from concrete details</li><li>Modes of abstraction:<ul><li>Via languages/compilers: Higher-level code, few machine dependencies</li><li>Via subroutines: Abstract interface to behavior</li><li>Via modules: Export interfaces; hide implementation</li><li>Via abstract data types: Bundle data with its operations</li></ul></li></ul><p><strong>Types</strong>:</p><ul><li>Originally, few types<ul><li>FORTRAN: scalars, arrays</li><li>LISP: no static type distinctions</li></ul></li><li>Realization: Types help<ul><li>Allow the programmer to express abstraction</li><li>Allow the compiler to check against many frequent errors</li><li>Sometimes to the point that programs are guaranteed “safe”</li></ul></li><li>More recently<ul><li>Lots of interest in types</li><li>Experiments with various forms of parameterization</li><li>Best developed in functional programming</li></ul></li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture02.pdf" target="_blank" rel="noopener">Language Design</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Learning Compiler 1 Overview</title>
      <link href="/2019/05/18/Learn-complier-1/"/>
      <url>/2019/05/18/Learn-complier-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h2><h3 id="Strategies"><a href="#Strategies" class="headerlink" title="Strategies"></a>Strategies</h3><ul><li>Interpreters(slightly order)</li><li>Compilers(slightly newer)</li></ul><h3 id="Difference-Between-Interpreters-and-Compilers"><a href="#Difference-Between-Interpreters-and-Compilers" class="headerlink" title="Difference Between Interpreters and Compilers"></a>Difference Between Interpreters and Compilers</h3><ul><li>Interpreters run programs “as is”: little or no preprocessing</li><li>Compilers do extensive preprocessing</li></ul><h3 id="Language-Implementations"><a href="#Language-Implementations" class="headerlink" title="Language Implementations"></a>Language Implementations</h3><ul><li>Low level: C/C++</li><li>Higher level: Python</li><li>Interpreter + “Just In Time”(JIT) compiler: Java</li></ul><h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>FORTRAN I</p><h3 id="Struture-of-Compiler"><a href="#Struture-of-Compiler" class="headerlink" title="Struture of Compiler"></a>Struture of Compiler</h3><ol><li>Lexical analysis</li><li>Parsing</li><li>Semantic analysis</li><li>Optimization</li><li>Code generation</li></ol><ul><li><p>Lexical analysis: First step: recognize words. Divides program text into “words” or “tokens”.</p></li><li><p>Parsing: Understand sentence structure. Parsing = Diagramming Sentences(a tree).</p></li><li><p>Semantic analysis: Understand “meaning”. Compilers perform limited analysis to catch inconsistencies, and many semantic checks besides variable bindings.</p></li><li><p>Optimization: Automatically modify programs to run faster, use less memory and in general, conserve some resource.</p></li><li><p>Code generation: Usually produces assembly code. A translation into another language.</p></li></ul><h3 id="Intermediate-Languages-IL"><a href="#Intermediate-Languages-IL" class="headerlink" title="Intermediate Languages(IL)"></a>Intermediate Languages(IL)</h3><p>Many compilers perform translations between successive intermediate forms:</p><ul><li>All but first and last are intermediate languages internal to the compiler</li><li>Typically there is 1 IL</li></ul><p>IL’s generally ordered in descending level of abstraction</p><ul><li>Highest is source</li><li>Lowest is assembly</li></ul><p>IL’s are useful because lower levels expose features hidden by higher levels</p><ul><li>registers</li><li>memory layout</li><li>etc.</li></ul><p>But lower levels obscure high-level meaning</p><h3 id="Issues"><a href="#Issues" class="headerlink" title="Issues"></a>Issues</h3><p>Language design has big impact on compiler</p><ul><li>Determines what is easy and hard to compile</li><li>Course theme: many trade-offs in language design</li></ul><h3 id="Today’s-Compiler"><a href="#Today’s-Compiler" class="headerlink" title="Today’s Compiler"></a>Today’s Compiler</h3><p>The proportions have changed since FORTRAN</p><ul><li>Early: lexing, parsing most complex, expensive</li><li>Today: optimization dominates all other phases, lexing and parsing are cheap</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Slides: <a href="http://web.stanford.edu/class/cs143/lectures/lecture01.pdf" target="_blank" rel="noopener">Overview</a></p><p>Video: <a href="https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/course/" target="_blank" rel="noopener">Compiler Stanford 2014</a></p>]]></content>
      
      
      <categories>
          
          <category> 学不死就往死里学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
            <tag> Compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一条博客</title>
      <link href="/2019/05/06/First-Blog/"/>
      <url>/2019/05/06/First-Blog/</url>
      
        <content type="html"><![CDATA[<p>我如果不发一条这么无聊的博客当做第一条博客，那么网站就无法生成……嗯回头我再写一篇详细介绍我的创建过程吧。晚安。</p>]]></content>
      
      
      <categories>
          
          <category> Chaos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boring </tag>
            
            <tag> First </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
